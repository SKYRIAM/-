链接：https://www.nowcoder.com/questionTerminal/36be7bb128814755bbcc43788602adfe
来源：牛客网
### 树的节点
    N = N0+N1+N2       （节点总数由度为一的节点数+度为2的节点数+度为3的节点数）
    N-1= 0*N0+1*N1+2*N2    （从下往上以树枝看，一个节点对应一个树枝，除了根节点外，因此共有N-1根树枝，这个式子表示的是树枝的关系）
    通过两式做差可得：
     N2-N0=-1即N0=N2+1
### 二叉查找树
二叉排序树中序遍历的结果是从小打大完全有序的序列。题目中说两棵树的关键字集合相同，所以得到的有序序列也是相同的

### 二叉树转换为森林
从根结点开始,若右孩子存在,则把与右孩子的结点的连线删除,在查看分离后的二叉树,若右孩子存在,删除….直到所有的右孩子连线都删除为止,得到分离的二叉树
每棵分离后的二叉树转化为树即可.
![二叉树](https://img-blog.csdn.net/20150706213213838)

###  二叉树公式
1. 节点的度：一个节点含有的子树的个数称为该节点的度； 
2. 叶节点或终端节点：度为零的节点； 
3. 非终端节点或分支节点：度不为零的节点； 
4. 父亲节点或父节点：若一个节点含有子节点，则这个节点称为其子节点的父节点； 
5. 兄弟节点：具有相同父节点的节点互称为兄弟节点； 
6. 节点的层次：从根开始定义起，根为第1层，根的子节点为第2层，以此类推； 
7. 树的高度或深度：树中节点的最大层次； 
8. 堂兄弟节点：父节点在同一层的节点互为堂兄弟； 
9. 节点的祖先：从根到该节点所经分支上的所有节点； 
10. 孙：以某节点为根的子树中任一节点都称为该节点的子孙。 
11. 森林：由m（m>=0）棵互不相交的树的集合称为森林； 
12. 满二叉树：一棵深度为k，且有2^k-1 (2的k次方减一)个节点称之为满二叉树 
13. 完全二叉树：完全二叉树是由满二叉树而引出来的。对于深度为K的，有n个结点的二叉树，当且仅当其每一个结点都与深度为K的满二叉树中编号从1至n的结点一一对应时称之为完全二叉树。

##### 性质：

1. 在非空二叉树中，第i层的结点总数不超过2^(i-1),i>=1； 
2. 深度为h的二叉树最多有2^h-1个结点(h>=1)，最少有h个结点； 
3. 对于任意一棵二叉树，如果其叶结点数为N0，而度数为2的结点总数为N2，则N0=N2+1； 
4. 具有n个结点的完全二叉树的深度为K =[log2n」+1(取下整数) 
5. 有N个结点的完全二叉树各结点如果用顺序方式存储，则结点之间有如下关系： 若I为结点编号则 如果I>1，则其父结点的编号为I/2； 
如果2*I<=N，则其左儿子（即左子树的根结点）的编号为2*I；若2*I>N，则无左儿子； 如果2*I+1<=N，则其右儿子的结点编号为2*I+1；若2*I+1>N，则无右儿子。 6 6. 给定N个节点，能构成h(N)种不同的二叉树。h(N)为卡特兰数的第N项。h(n)=C(2*n，n)/(n+1)。 
7. 设有i个枝点，I为所有枝点的道路长度总和，J为叶的道路长度总和J=I+2i

##### 二叉树的遍历三种方式，如下： 
1. 前序遍历（DLR），首先访问根结点，然后遍历左子树，最后遍历右子树。简记根-左-右。 
2. 中序遍历（LDR），首先遍历左子树，然后访问根结点，最后遍历右子树。简记左-根-右。 
3. 后序遍历（LRD），首先遍历左子树，然后遍历右子树，最后访问根结点。简记左-右-根


### 关于图的几个概念定义：

- 连通图：在无向图中，若任意两个顶点vivi与vjvj都有路径相通，则称该无向图为连通图。
- 强连通图：在有向图中，若任意两个顶点vivi与vjvj都有路径相通，则称该有向图为强连通图。
- 连通网：在连通图中，若图的边具有一定的意义，每一条边都对应着一个数，称为权；权代表着连接连个顶点的代价，称这种连通图叫做连通网。
- 生成树：一个连通图的生成树是指一个连通子图，它含有图中全部n个顶点，但只有足以构成一棵树的n-1条边。一颗有n个顶点的生成树有且仅有n-1条边，如果生成树中再添加一条边，则必定成环。
- 最小生成树：在连通网的所有生成树中，所有边的代价和最小的生成树，称为最小生成树。

#### 1.Kruskal算法
此算法可以称为“加边法”，初始最小生成树边数为0，每迭代一次就选择一条满足条件的最小代价边，加入到最小生成树的边集合里。 
1. 把图中的所有边按代价从小到大排序； 
2. 把图中的n个顶点看成独立的n棵树组成的森林； 
3. 按权值从小到大选择边，所选的边连接的两个顶点ui,viui,vi,应属于两颗不同的树，则成为最小生成树的一条边，并将这两颗树合并作为一颗树。 
4. 重复(3),直到所有顶点都在一颗树内或者有n-1条边为止。
![](https://img-blog.csdn.net/20160714144315409)

#### 2.Prim算法
1. 此算法可以称为“加点法”，每次迭代选择代价最小的边对应的点，加入到最小生成树中。算法从某一个顶点s开始，逐渐长大覆盖整个连通网的所有顶点。
2. 图的所有顶点集合为VV；初始令集合u={s},v=V−uu={s},v=V−u;
3. 在两个集合u,vu,v能够组成的边中，选择一条代价最小的边(u0,v0)(u0,v0)，加入到最小生成树中，并把v0v0并入到集合u中。
4. 重复上述步骤，直到最小生成树有n-1条边或者n个顶点为止。
5. 由于不断向集合u中加点，所以最小代价边必须同步更新；需要建立一个辅助数组closedge,用来维护集合v中每个顶点与集合u中最小代价边信息，：
![a](https://img-blog.csdn.net/20160714161107576)
## 线索二叉树
二叉树线索化后，先序线索化与后序线索化最多有1个空指针域，而中序线索化最多有2个空指针域
(https://blog.csdn.net/u014492609/article/details/40477795)
## 二叉搜索树

## 二叉排序树

## B树/B+树/B-树
