### 短连接 
连接->传输数据->关闭连接 
比如HTTP是无状态的的短链接，浏览器和服务器每进行一次HTTP操作，就建立一次连接，但任务结束就中断连接。 
具体就是 浏览器client发起并建立TCP连接 -> client发送HttpRequest报文 -> server接收到报文->server handle并发送HttpResponse报文给前端,发送完毕之后立即调用socket.close方法->client接收response报文->client最终会收到server端断开TCP连接的信号->client 端断开TCP连接，具体就是调用close方法。 
也可以这样说：短连接是指SOCKET连接后，发送接收完数据后马上断开连接。 因为连接后接收了数据就断开了，所以每次数据接受处理不会有联系。 这也是HTTP协议无状态的原因之一。

### 长连接 
连接->传输数据->保持连接 -> 传输数据-> ………..->直到一方关闭连接，多是客户端关闭连接。 长连接指建立SOCKET连接后不管是否使用都保持连接，但安全性较差。

HTTP在短链接和长连接上的选择：HTTP是无状态的 ，也就是说，浏览器和服务器每进行一次HTTP操作，就建立一次连接，但任务结束就中断连接。如果客户端浏览器访问的某个HTML或其他类型的 Web页中包含有其他的Web资源，如JavaScript文件、图像文件、CSS文件等；当浏览器每遇到这样一个Web资源，就会建立一个HTTP会话 
HTTP1.1和HTTP1.0相比较而言，最大的区别就是增加了持久连接支持(貌似最新的HTTP1.1 可以显示的指定 keep-alive),但还是无状态的，或者说是不可以信任的。 
如果浏览器或者服务器在其头信息加入了这行代码 Connection:keep-alive TCP连接在发送后将仍然保持打开状态，于是，浏览器可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了带宽。 
实现长连接要客户端和服务端都支持长连接。

### 什么时候用长连接，短连接？ 
长连接多用于操作频繁，点对点的通讯，而且连接数不能太多情况，。每个TCP连接都需要三步握手，这需要时间，如果每个操作都是先连接，再操作的话那么处理速度会降低很多，所以每个操作完后都不断开，次处理时直接发送数据包就OK了，不用建立TCP连接。例如：数据库的连接用长连接， 如果用短连接频繁的通信会造成socket错误，而且频繁的socket 创建也是对资源的浪费。 
而像WEB网站的http服务一般都用短链接，因为长连接对于服务端来说会耗费一定的资源，而像WEB网站这么频繁的成千上万甚至上亿客户端的连接用短连接会更省一些资源，如果用长连接，而且同时有成千上万的用户，如果每个用户都占用一个连接的话，那可想而知吧。所以并发量大，但每个用户无需频繁操作情况下需用短连好。 
总之，长连接和短连接的选择要视情况而定。 
具体网络中的应用的话：http 1.0一般就指短连接，smtp,pop3,telnet这种就可以认为是长连接。一般的网络游戏应用都是长连接

### 处理哈希冲突
1. 开放定址法（再散列法）
在开法定址法中，哈希表中的空闲单元（记为d）不仅允许哈希地址为d的同义词关键字使用，而且也允许发生冲突的其他关键字使用。开法定址法的名字就是来自于此方法的哈希表空闲单元既向同义词开放，也向发生冲突的非同义词关键字开放。谁先找到这个单元谁先占用，这和哈希表的元素排列次序有关。开放定址法以发生冲突的地址d作为自变量来得到一个新的空闲单元，下面介绍常用的几种。（d加下标i记为d[i]，小i打不出来==）
1. 线性探查法
发生冲突时，线性遍历后续单元直到找到空闲单元。即d[i] = (d[i-1] + 1) mod m线性探查容易产生堆积的问题。因为若是出现了若干个同意词会堆积在第一个同义词的地址单元附近。
2. 平方探查法
发生冲突时，用平方探查法的探查序列为d[i] + 1²，d[i] + 2², d[i] + 3²...直到找到空闲单元。平方探查法是一种比较好的处理冲突的方法，可以避免堆积问题。它的缺点是不能探查到哈希表上的所有单元，不过至少也能探查到一半单元。etc
2. 链地址法（拉链法）
链地址法的思想是将哈希表的每个单元作为链表的头结点，所有哈希地址为i的元素构成一个同义词链表。即发生冲突时就把该关键字链在以该单元为头结点的链表的尾部。（图得靠自己脑补）链地址法适用于经常插入删除的情况，其中查找、插入和删除操作主要在同义词链中进行。
3. 再哈希法
在构造函数时同时构造多个不同的哈希函数。当哈希地址发生冲突用其他的函数计算另一个哈希函数地址，直到冲突不再产生为止。这种方法不易产生聚集，但增加了计算时间。
4. 建立公共溢出区
建立公共溢出区的基本思想是将哈希表分为基本表和溢出表2部分，发生冲突的元素都放入溢出表中。

### 判断平衡二叉树
平衡二叉树，又称AVL树。它或者是一棵空树，或者是具有下列性质的二叉树：它的左子树和右子树都是平衡二叉树，且左子树和右子树的高度之差之差的绝对值不超过1.。
### 数据库索引
索引的基础

索引类似于书籍的目录，要想找到一本数的某个特定主题，需要先查找书的目录，定位对应的页码  
存储引擎使用类似的方式进行数据查询，先去索引当中找到对应的值，然后根据匹配的索引找到对应的数据行。  
#### 创建索引的语法：

首先创建一个表：create table t1 (id int primary key,username varchar(20),password varchar(20));    
创建单个索引的语法：CREATE INDEX 索引名 on 表名（字段名）  
索引名一般是：表名_字段名  
给id创建索引：CREATE INDEX t1_id on t1(id);  
创建联合索引的语法：CREATE INDEX 索引名 on 表名（字段名1，字段名2）  
给username和password创建联合索引：CREATE index t1_username_password ON t1(username,password)  
其中index还可以替换成unique，primary key，分别代表唯一索引和主键索引  
删除索引：DROP INDEX t1_username_password ON t1  
#### 索引对性能的影响：

大大减少服务器需要扫描的数据量。  
帮助服务器避免排序和临时表。  
将随机I/O变顺序I/O。  
大大提高查询速度。  
降低写的速度（不良影响）。  
磁盘占用（不良影响）。  
#### 索引的使用场景：

对于非常小的表，大部分情况下全表扫描效率更高。  
中到大型表，索引非常有效。  
特大型的表，建立和使用索引的代价会随之增大，可以使用分区技术来解决。  
#### 索引的类型：

索引很多种类型，是在MySQL的存储引擎实现的。  

普通索引：最基本的索引，没有任何约束限制。  
唯一索引：和普通索引类似，但是具有唯一性约束。  
主键索引：特殊的唯一索引，不允许有空值。  
#### 索引的区别：

-一个表只能有一个主键索引，但是可以有多个唯一索引。  

主键索引一定是唯一索引，唯一索引不是主键索引。  
主键可以与外键构成参照完整性约束，防止数据不一致。  
联合索引：将多个列组合在一起创建索引，可以覆盖多个列。（也叫复合索引，组合索引）  
外键索引：只有InnoDB类型的表才可以使用外键索引，保证数据的一致性、完整性、和实现级联操作（基本不用）。  
全文索引：MySQL自带的全文索引只能用于MyISAM，并且只能对英文进行全文检索 （基本不用）  
#### MySQL索引的创建原则

最适合创建索引的列是出现在WHERE或ON子句中的列，或连接子句中的列而不是出现在SELECT关键字后的列。  
索引列的基数越大，数据区分度越高，索引的效果越好。  
对于字符串进行索引，应该制定一个前缀长度，可以节省大量的索引空间。  
根据情况创建联合索引，联合索引可以提高查询效率。  
避免创建过多的索引，索引会额外占用磁盘空间，降低写操作效率。  
主键尽可能选择较短的数据类型，可以有效减少索引的磁盘占用提高查询效率。  
